<?xml version="1.0" encoding="utf-8"?><!DOCTYPE nta PUBLIC '-//Uppaal Team//DTD Flat System 1.1//EN' 'http://www.it.uu.se/research/group/darts/uppaal/flat-1_1.dtd'><nta><declaration>//STATIONS
//Generated wih python script using TLE
const int STATION_INDEX = 34; // changes for; when station are in range
const int STATIONS = 3; // amount of windows i.e. stations to which can be communicated
const int STATION_ATTRI = 3; // elements discribing window
// Start_time, End_time, active or not
const int OVER_STATION[STATION_INDEX][STATIONS][STATION_ATTRI] = {
{{0, 51, 1}, {0, 30, 1}, {0, 4, 0}},
{{52, 68, 0}, {31, 88, 0}, {5, 27, 1}},
{{69, 139, 1}, {89, 118, 1}, {28, 92, 0}},
{{140, 156, 0}, {119, 176, 0}, {93, 116, 1}},
{{157, 227, 1}, {177, 207, 1}, {117, 181, 0}},
{{228, 245, 0}, {208, 265, 0}, {182, 204, 1}},
{{246, 316, 1}, {266, 295, 1}, {205, 269, 0}},
{{317, 333, 0}, {296, 353, 0}, {270, 292, 1}},
{{334, 404, 1}, {354, 383, 1}, {293, 357, 0}},
{{405, 421, 0}, {384, 441, 0}, {358, 380, 1}},
{{422, 492, 1}, {442, 472, 1}, {381, 446, 0}},
{{493, 510, 0}, {473, 530, 0}, {447, 469, 1}},
{{511, 581, 1}, {531, 560, 1}, {470, 534, 0}},
{{582, 598, 0}, {561, 618, 0}, {535, 557, 1}},
{{599, 669, 1}, {619, 648, 1}, {558, 622, 0}},
{{670, 686, 0}, {649, 706, 0}, {623, 645, 1}},
{{687, 757, 1}, {707, 736, 1}, {646, 711, 0}},
{{758, 775, 0}, {737, 795, 0}, {712, 734, 1}},
{{776, 846, 1}, {796, 825, 1}, {735, 799, 0}},
{{847, 863, 0}, {826, 883, 0}, {800, 822, 1}},
{{864, 934, 1}, {884, 913, 1}, {823, 887, 0}},
{{935, 951, 0}, {914, 971, 0}, {888, 910, 1}},
{{952, 1022, 1}, {972, 1001, 1}, {911, 975, 0}},
{{1023, 1040, 0}, {1002, 1059, 0}, {976, 999, 1}},
{{1041, 1111, 1}, {1060, 1090, 1}, {1000, 1064, 0}},
{{1112, 1128, 0}, {1091, 1148, 0}, {1065, 1087, 1}},
{{1129, 1199, 1}, {1149, 1178, 1}, {1088, 1152, 0}},
{{1200, 1216, 0}, {1179, 1236, 0}, {1153, 1175, 1}},
{{1217, 1287, 1}, {1237, 1266, 1}, {1176, 1240, 0}},
{{1288, 1305, 0}, {1267, 1324, 0}, {1241, 1264, 1}},
{{1306, 1376, 1}, {1325, 1355, 1}, {1265, 1329, 0}},
{{1377, 1393, 0}, {1356, 1413, 0}, {1330, 1352, 1}},
{{1394, 1440, 1}, {1414, 1440, 1}, {1353, 1417, 0}},
{{0, 9999, 0}, {0, 9999, 0}, {1418, 1440, 1}}};

typedef struct {
	int cost;
	int data_recieved;
} StationDescription;

// #Station0 // #Station1 // #Station2
StationDescription stations[STATIONS] = {{2,0},{4,0},{8,0}};
const int STATION_ZEROS[STATIONS] = {0,0,0};
int s_indexes[STATIONS] = STATION_ZEROS;

//CONVOYS
const int CONVOYS = 2;
typedef int[0, CONVOYS - 1] id_t;
const int CONVOY_ZEROS[CONVOYS] = {0,0};
const int MAX_PROCESSORS = 10;
const int TASKS = 3;
const int TASKS_ZEROS[TASKS] = {0,0,0};
typedef struct {
	int processors; // Number of task the convoy is allowed to perform in parallel
	int send_to_station[STATIONS]; // Number of stations the convoy is allowed to send to in parallel
	int send_to_convoy[CONVOYS]; // Number of convoys this convoy is allowed to send to in parallel 
	int gather_data;
	int storage;
	//Describe the relation between tasks and stations
	int tasks_depending_on_window[TASKS][STATIONS];
} ConvoyDescription;
typedef struct {
	int task_type;
	int execution_time;
	int data_rate;
} TaskDescription;
// #Convoy1
const ConvoyDescription convoys[CONVOYS] = {{9, {3,3,3}, {0,3}, 9, 1000, {{1,0,0},{0,1,1},{-1,-1,-1}}}, 
					    {9, {3,0,3}, {2,0}, 9, 2000, {{1,0,0},{1,1,1},{-1,-1,-1}}}};
// #0 Gather data  // #1 Send to station // #2 Send to convoy
const TaskDescription tasks[TASKS] = {{0,15, 2},{1,15, 2},{2,15,4}};
// Observe storage on each of the convoys
int storages[CONVOYS] = CONVOY_ZEROS;

//SCHEDULER
typedef struct {
	int task_type;
	int execution_time;
	int to;
} ExecutionDescription;
ExecutionDescription convoy_tasks[CONVOYS][MAX_PROCESSORS] = {{{-1,9999,-1},{-1,9999,-1},{-1,9999,-1},{-1,9999,-1},{-1,9999,-1},{-1,9999,-1},{-1,9999,-1},{-1,9999,-1},{-1,9999,-1},{-1,-1,-1}},
							      {{-1,9999,-1},{-1,9999,-1},{-1,9999,-1},{-1,9999,-1},{-1,9999,-1},{-1,9999,-1},{-1,9999,-1},{-1,9999,-1},{-1,9999,-1},{-1,-1,-1}}};
int current_task = 1;
int proc_in_use[CONVOYS] = CONVOY_ZEROS;
int gather_in_use[CONVOYS] = CONVOY_ZEROS;
int send_to_station[CONVOYS][STATIONS] = {STATION_ZEROS,STATION_ZEROS};
int send_to_convoy[CONVOYS] = CONVOY_ZEROS;
const int schedule_length = 1050;

//CHANNELS
broadcast chan suggest_task, assign_tasks, move;

//CLOCKS
clock TotalTime;

//Bools used to deadlock if constrains are violated
bool illegal_move = false;
bool execution_being_negative = false;
bool storage_overflow = false;
bool storage_underflow = false;
bool idle = false;



int obs_gather_cost[CONVOYS] = CONVOY_ZEROS;
int obs_sender_station_cost[CONVOYS] = CONVOY_ZEROS;
int obs_sender_convoy_cost[CONVOYS] = CONVOY_ZEROS;
int calculated_cost = 0;

//OBSERVABLE VARIABLES
int total_runs[CONVOYS][TASKS] = {TASKS_ZEROS, TASKS_ZEROS}; 
int total_convoy_recived[CONVOYS] = CONVOY_ZEROS;
int total_convoy_send[CONVOYS] = CONVOY_ZEROS;


//UTILITY METHODS
const int MAX_VALUE = 9999;

void sort_lists(){
	int i,c,j;
	ExecutionDescription swap = {0,0,0};
	for (c = 0 ; c &lt; CONVOYS ; c++){
		for (i = 0 ; i &lt; convoys[c].processors - 1 ; i++){
			for (j = 0 ; j &lt; convoys[c].processors - i - 1 ; j++){
				if (convoy_tasks[c][j].execution_time &gt;= convoy_tasks[c][j+1].execution_time){
					swap = convoy_tasks[c][j];
					convoy_tasks[c][j] = convoy_tasks[c][j+1];
					convoy_tasks[c][j+1] = swap;
				}
			}	
		}
	}
}



</declaration><template><name>Scheduler</name><declaration>clock time;
int lowest;
int fake_clock = 0;


int tm = MAX_VALUE;
int window_count = 0;

//Look at the stations to see how much time needs to be advanced before a window change appears.
int nearest_window(){
	int s, i;
	bool found = false;
	tm = MAX_VALUE;
	if (true){ // Check if any of the convoys has any tasked queued
		for (s = 0; s &lt; STATIONS; s++){
			found = false;
			for (i = s_indexes[s]; i &lt; STATION_INDEX; i++){
				if (tm &gt; OVER_STATION[i][s][1]+1 &amp;&amp; !found &amp;&amp; OVER_STATION[i][s][2] == 1){
					tm = OVER_STATION[i][s][1]+1;
					found = true;
				}
			}
		}
		return fake_clock+1;// NEED FIXING, produces errors when it return tm-fake_clock
	}
}

//Sets the lowest variable equal to the lowest amount of time before any of the tasks finishes.
void closest_task_to_finish(){	
	int i;
	lowest = MAX_VALUE;	
	for (i = 0; i &lt; CONVOYS; i++){
		if (convoy_tasks[i][0].execution_time &lt; lowest){
			lowest = convoy_tasks[i][0].execution_time;
		}
	}
	if (lowest == MAX_VALUE){
		idle = true;
		window_count++;
		lowest = nearest_window()- fake_clock;
	}
}

//Updates the processors lists, and free processes if they have finshed their task.
void update_processors(){
	int i, c;
	for (c = 0; c &lt; CONVOYS; c++){
		for (i = 0; i &lt; convoys[c].processors; i++){
			if (convoy_tasks[c][i].task_type != -1){
				convoy_tasks[c][i].execution_time -= lowest;
			}
			if (convoy_tasks[c][i].execution_time == 0){
				if (convoy_tasks[c][i].to != -1){
					send_to_station[c][convoy_tasks[c][i].to]--;
				}
				if (convoy_tasks[c][i].task_type == 0){
					gather_in_use[c]--;
				}
				proc_in_use[c]--;
				convoy_tasks[c][i].to = -1;
				convoy_tasks[c][i].task_type = -1;
				convoy_tasks[c][i].execution_time = MAX_VALUE;
			}
			else if (convoy_tasks[c][i].execution_time &lt; 0 &amp;&amp; convoy_tasks[c][i].task_type != -1){
				execution_being_negative = true;
			}
		}
	}
}
//Updates the storages for each convoy based of the amount of time moved and number of processors performed tasks that effect storage.
void update_storage(){
	int i, c;
	for (c = 0; c &lt; CONVOYS; c++){
		for (i = 0; i &lt; MAX_PROCESSORS; i++){
			if (convoy_tasks[c][i].task_type == 0){ //Gather data
				storages[c] += tasks[convoy_tasks[c][i].task_type].data_rate * lowest;
				if (storages[c] &gt; convoys[c].storage){
					storage_overflow = true;
				}
			}
			else if (convoy_tasks[c][i].task_type == 1){ //Send data to Earth
				storages[c] -= tasks[convoy_tasks[c][i].task_type].data_rate * lowest;
				stations[convoy_tasks[c][i].to].data_recieved += tasks[convoy_tasks[c][i].task_type].data_rate * lowest;
				if (storages[c] &lt; 0){
					storage_underflow = true;
				}
			}
			else if (convoy_tasks[c][i].task_type == 2){ //Send data to convoy
				storages[c] -= tasks[convoy_tasks[c][i].task_type].data_rate * lowest;
				storages[convoy_tasks[c][i].to] += tasks[convoy_tasks[c][i].task_type].data_rate * lowest;
				total_convoy_recived[convoy_tasks[c][i].to] += tasks[convoy_tasks[c][i].task_type].data_rate * lowest;
				total_convoy_send[c] += tasks[convoy_tasks[c][i].task_type].data_rate * lowest;
				if (storages[c] &lt; 0){
					storage_underflow = true;//Ultimately remove them and check after to ensure that there isen't an overflow because gather data is calculated before sending to earth and other convoys.
				}
			}
		}
	}
}






//Enforces that scheduler is less likely to idle to reduce state-space
void check_idle(){
	if (idle){
		calculated_cost += 1000;
		idle = false;
	}
}

//Check if the scheduler has made a move that result in either storage under- or over-flowing, and more.
bool check_constrains(){
	if (illegal_move){
		return false;
	}
	else if (execution_being_negative){
		return false;
	}
	else if (storage_overflow){
		return false;
	}
	else if (storage_underflow){
		return false;
	}
	return true;
}

//Increment the s_indexes to look at the correct windows.
void update_windows(){
	int s;
	for (s = 0; s &lt; STATIONS; s++){
		while(OVER_STATION[s_indexes[s]][s][1] &lt; fake_clock){
			s_indexes[s]++;
		}
	}
}
</declaration><location id="id0" x="-480" y="184"><committed/></location><location id="id1" x="-480" y="-16"><committed/></location><location id="id2" x="-256" y="184"><name x="-248" y="152">WaitingForTasks</name><label kind="invariant" x="-266" y="199">time &lt;= lowest &amp;&amp;
TotalTime &lt; schedule_length &amp;&amp;
lowest != 0 &amp;&amp;
check_constrains() &amp;&amp;
cost '== calculated_cost</label></location><location id="id3" x="-64" y="-16"><committed/></location><location id="id4" x="-256" y="-16"><committed/></location><init ref="id4"/><transition><source ref="id1"/><target ref="id0"/><label kind="assignment" x="-472" y="56">time = 0,
sort_lists(),
closest_task_to_finish()</label></transition><transition><source ref="id0"/><target ref="id2"/></transition><transition><source ref="id3"/><target ref="id4"/><label kind="synchronisation" x="-240" y="-120">move!</label><label kind="assignment" x="-240" y="-96">current_task++</label><nail x="-64" y="-96"/><nail x="-256" y="-96"/></transition><transition><source ref="id2"/><target ref="id4"/><label kind="guard" x="-248" y="8">time == lowest</label><label kind="assignment" x="-248" y="24">current_task = 1,
fake_clock += lowest,
update_storage(),
update_processors(),
update_windows(),
sort_lists()</label></transition><transition><source ref="id4"/><target ref="id1"/><label kind="guard" x="-440" y="-40">current_task == TASKS</label><label kind="synchronisation" x="-440" y="-56">assign_tasks!</label></transition><transition><source ref="id4"/><target ref="id3"/><label kind="guard" x="-224" y="-40">current_task != TASKS</label><label kind="synchronisation" x="-224" y="-56">suggest_task!</label></transition></template><template><name>Convoy</name><parameter>const id_t id</parameter><declaration>//Used in accept_suggestion(), reject_suggestion(), and lastly used in add_tasks()
int decisions[TASKS] = {1, 0, 0};

//Indicate that the convoy will execute the task
void accept_suggestion(){
	decisions[current_task] = 1;
}

//Indicate that the convoy will not execute the specifyed task
void reject_suggestion(){
	decisions[current_task] = 0;
}

//Calculates how many processors need to be assigned to the accepted tasks
int amount_of_tasks_to_execute(int t){
	if (t == 0 &amp;&amp; obs_gather_cost[id] != 0){
		return (obs_gather_cost[id]*convoys[id].processors - proc_in_use[id])/(obs_gather_cost[id] + obs_sender_station_cost[id]);
	}
	else if (t == 1 &amp;&amp; obs_sender_station_cost[id] != 0){
		return (obs_sender_station_cost[id]*convoys[id].processors - proc_in_use[id])/obs_sender_station_cost[id];
	}
	else if (t == 2 &amp;&amp; obs_sender_convoy_cost[id] != 0){
		return 1;
	}
	else{
		return 1;
	}
}

//Finds the lowest cost from the available stations and return the index position of the station
int cheapest_available_station(){
	int s;
	int lowest = MAX_VALUE;
	int position = 0;
	for (s = 0; s &lt; STATIONS; s++){
		if (convoys[id].send_to_station[s] &gt; send_to_station[id][s]){
			if (stations[s].cost &lt; lowest){
				lowest = stations[s].cost;
				position = s;
			}
		}
	}
	if (lowest == MAX_VALUE){
		position = MAX_VALUE;
	}
	return position;	
}

//Finds the convoy with the lowest amount of storage in relation to its maximum cappacity and returns the index position of the convoy
int lowest_available_convoy(){
	int c;
	int lowest = MAX_VALUE;
	int position = 0;
	for (c = 0; c &lt; CONVOYS; c++){
		if(convoys[id].send_to_convoy[c] &gt; send_to_convoy[c] &amp;&amp; c != id){
			if (storages[c] &lt; lowest){
				lowest = storages[c];
				position = c;
			}
		}
	}
	if (lowest == MAX_VALUE){
		position = MAX_VALUE;
	}
	return position;
}

//Check if the convoy can execute the task, identifyed by the parameter task_id to see if they are depending on a window and check we the convoy is within set window.
bool task_within_station(int task_id){
	int s;
	for (s = 0; s &lt; STATIONS; s++){
		if (convoys[id].tasks_depending_on_window[task_id][s] || convoys[id].tasks_depending_on_window[task_id][s] == -1){
			return true;
		}
	}
	return false;
}

//Used by add_tasks(), this adds the tasks to the convoys processor list, based on the given parameter.
void insert_task(TaskDescription item){
	int p, station_index, convoy_index;
	for(p = 0; p &lt; convoys[id].processors; p++){
		if (convoy_tasks[id][p].task_type == -1  &amp;&amp; task_within_station(item.task_type)){
			if (item.task_type == 0){// Gather data
				proc_in_use[id]++;
				convoy_tasks[id][p].task_type = item.task_type;
				convoy_tasks[id][p].execution_time = item.execution_time;
				convoy_tasks[id][p].to = -1;
				gather_in_use[id]++;
				total_runs[id][item.task_type]++;
				return;
			}
			else if (item.task_type == 1){//Send to station
				station_index = cheapest_available_station();
				if (station_index == 9999){
					return;
				}
				else{
					proc_in_use[id]++;
					convoy_tasks[id][p].task_type = item.task_type;
					convoy_tasks[id][p].execution_time = item.execution_time;
					convoy_tasks[id][p].to = station_index;
					send_to_station[id][convoy_tasks[id][p].to]++;
					total_runs[id][item.task_type]++;
					return;
				}
			}
			else if (item.task_type == 2){//Send to convoy
				convoy_index = lowest_available_convoy();
				if (convoy_index == 9999){
					return;
				}
				else{
					proc_in_use[id]++;
					convoy_tasks[id][p].task_type = item.task_type;
					convoy_tasks[id][p].execution_time = item.execution_time;
					convoy_tasks[id][p].to = convoy_index;
					total_runs[id][item.task_type]++;
					return;
				}
			}		
		}
	}
	
}
//Called after cost has been calculated in the template, because insert_task uses the cost to determine the number of proccesers that needs to perform each task.
void add_tasks(){
	int t, amount;
	for (t = 0; t &lt; TASKS; t++){
		if (decisions[t]){
			amount = amount_of_tasks_to_execute(t);
			while(amount){
				insert_task(tasks[t]);
				amount--;
			}
		}
		decisions[t] = 0;// Reset decision.	
		if (t == 0){
			decisions[t] = 1;
		}
	}
}

//Template guard - forces gather data to be taken if storage is below 50%
bool gather_data(){
	if (current_task == 0){
		if (storages[id] &gt; convoys[id].storage/2){
			return true;
		}
		else{
			return false;
		}
	}
	else{
		return true;
	}
}

//Template guard - forces send data to Earth to be taken if storage is above 50%
bool send_data_to_earth(){
	if (current_task == 1){
		if (storages[id] &lt; convoys[id].storage/2){
			return true;
		}
		else{
			return false;
		}
	}
	else{
		return true;	
	}
}

//Checks if the current task's window is available
bool check_station_windows(){
	int s;
	for (s = 0; s &lt; STATIONS; s++){
		if (convoys[id].tasks_depending_on_window[current_task][s] == 1 &amp;&amp; OVER_STATION[s_indexes[s]][s][2]){
			return true;
		}
		else if (convoys[id].tasks_depending_on_window[current_task][s] == -1){
			return true;
		}
	}
	return false;
}

//return the highest cost out of all the available stations for the individual convoy. Used in calc_cost method.
int find_highest_cost(int c){
	int s;
	int highest = 0;
	for (s = 0; s &lt; STATIONS; s++){
		if(convoys[c].send_to_station[s] != 0 &amp;&amp; stations[s].cost &gt; highest){
			highest = stations[s].cost;
		}
	}
	return highest;
}

//Calculate the cost based on storage, processors in use, and task distribution amount processors.
void calc_cost(){
	int i, c, s, p;
	int sender_cost[CONVOYS][STATIONS] = {STATION_ZEROS, STATION_ZEROS};
	int total_cost = 0;
	int internal_cost = 0;
	calculated_cost = 0;	
	for (c = 0; c &lt; CONVOYS; c++){
		total_cost = 0;
		obs_sender_station_cost[c] = 0;
		//Cost goes up if we have low storage and no processes gathering data.
		if ((100-storages[c]*100/convoys[c].storage)*(100-gather_in_use[c]*100/convoys[c].processors)/1000 &gt;=
		    (storages[c]*100/convoys[c].storage)*(gather_in_use[c]*100/convoys[c].processors)/1000){
			calculated_cost += (100-storages[c]*100/convoys[c].storage)*(100-gather_in_use[c]*100/convoys[c].processors)/1000;
			obs_gather_cost[c] = (100-storages[c]*100/convoys[c].storage)*(100-gather_in_use[c]*100/convoys[c].processors)/1000;
		}
		else {
			calculated_cost += (storages[c]*100/convoys[c].storage)*(gather_in_use[c]*100/convoys[c].processors)/1000;
			obs_gather_cost[c] = (storages[c]*100/convoys[c].storage)*(gather_in_use[c]*100/convoys[c].processors)/1000;
		}
		//Cost goes up if we have high storage and no procceses sending to other convoys or stations on Earth
		internal_cost = find_highest_cost(c);
		for (s = 0; s &lt; STATIONS ; s++){
			sender_cost[c][s] = 0;
			if (convoys[c].send_to_station[s] != 0){
				if (((100-storages[c]*100/convoys[c].storage) * ((internal_cost*10)/stations[s].cost)) + (((internal_cost*10)/stations[s].cost) * (100-send_to_station[c][s]*100/convoys[c].send_to_station[s])) &lt;
				    ((storages[c]*100/convoys[c].storage) * ((internal_cost*10)/stations[s].cost)) + (((internal_cost*10)/stations[s].cost) * (send_to_station[c][s]*100/convoys[c].send_to_station[s]))){
					sender_cost[c][s] = ((100-storages[c]*100/convoys[c].storage) * ((internal_cost*10)/stations[s].cost)) + (((internal_cost*10)/stations[s].cost) * (100-send_to_station[c][s]*100/convoys[c].send_to_station[s]));
				}
				else{
					sender_cost[c][s] = ((storages[c]*100/convoys[c].storage) * ((internal_cost*10)/stations[s].cost)) + (((internal_cost*10)/stations[s].cost) * (send_to_station[c][s]*100/convoys[c].send_to_station[s]));
				}
			}
			total_cost += (internal_cost*10)/stations[s].cost;
			obs_sender_station_cost[c] += sender_cost[c][s]/100;
		}
		obs_sender_station_cost[c] /= total_cost/10;
		calculated_cost += obs_sender_station_cost[c];


	}
}









</declaration><location id="id5" x="-160" y="16"><committed/></location><location id="id6" x="-160" y="-72"><committed/></location><location id="id7" x="-392" y="-40"></location><init ref="id7"/><transition><source ref="id7"/><target ref="id7"/><label kind="synchronisation" x="-600" y="-72">assign_tasks?</label><label kind="assignment" x="-600" y="-32">calc_cost(),
add_tasks()</label><nail x="-608" y="-48"/><nail x="-608" y="-32"/></transition><transition><source ref="id6"/><target ref="id7"/><label kind="synchronisation" x="-360" y="-160">move?</label><nail x="-160" y="-136"/><nail x="-392" y="-136"/></transition><transition><source ref="id5"/><target ref="id7"/><label kind="synchronisation" x="-360" y="88">move?</label><nail x="-160" y="104"/><nail x="-392" y="104"/></transition><transition><source ref="id7"/><target ref="id5"/><label kind="guard" x="-360" y="-8">check_station_windows()</label><label kind="synchronisation" x="-360" y="-24">suggest_task?</label><label kind="assignment" x="-360" y="16">accept_suggestion()</label><nail x="-368" y="16"/></transition><transition><source ref="id7"/><target ref="id6"/><label kind="guard" x="-360" y="-112">gather_data() &amp;&amp;
send_data_to_earth()</label><label kind="synchronisation" x="-360" y="-128">suggest_task?</label><label kind="assignment" x="-360" y="-72">reject_suggestion()</label><nail x="-376" y="-72"/></transition></template><system>
system Convoy, Scheduler;</system></nta>