<?xml version="1.0" encoding="utf-8"?><!DOCTYPE nta PUBLIC '-//Uppaal Team//DTD Flat System 1.1//EN' 'http://www.it.uu.se/research/group/darts/uppaal/flat-1_1.dtd'><nta><declaration>// Place global declarations here.
const int CONVOYS = 1;
const int ZEROS[CONVOYS] = {0};
//const int CHOICE = 2;
const int STATIONS = 3;
const int TASKS = 2;
const int TASKS_ZERO[TASKS] = {0,0};
const int MAX_PROCESSORS = 10;
typedef int[0, CONVOYS - 1] id_t;

broadcast chan start_data_transfer;
broadcast chan move;

typedef struct {
	int processors; // Number of task the convoy is allowed to perform in parallel
	int send_to_station[STATIONS]; // Number of stations the convoy is allowed to send to in parallel
	int send_to_convoy[CONVOYS]; // Number of convoys this convoy is allowed to send to in parallel 
	int gather_data;
	int storage;
} ConvoyDescription;

typedef struct {
	int task_type;
	int execution_time;
	int data_rate;
} TaskDescription;

typedef struct {
	int cost;
	int data_recieved;
} StationDescription;

typedef struct {
	int task_type;
	int execution_time;
	int to_station;
} ExecutionDescription;

//const ConvoyDescription c2 = {15,{0,3},{0}};
const ConvoyDescription convoys[CONVOYS] = {{9,{2,1,0},{0}, 10, 3600}};
const TaskDescription t1 = {0,10, 5}; // Gather data
const TaskDescription t2 = {1,5, 10}; // Send to Station
const TaskDescription tasks[TASKS] = {t1,t2};

StationDescription stations[STATIONS] = {{2,0},{5,0},{10,0}};
int storages[CONVOYS] = {0};
int to_be_stored[CONVOYS] = {0};
ExecutionDescription convoy_tasks[CONVOYS][MAX_PROCESSORS] = {{{-1,9999,-1},{-1,9999,-1},{-1,9999,-1},{-1,9999,-1},{-1,9999,-1},{-1,9999,-1},{-1,9999,-1},{-1,9999,-1},{-1,9999,-1},{-1,-1,-1}}};

int current_task = 0;

int proc_in_use[CONVOYS] = ZEROS;
int gather_in_use[CONVOYS] = ZEROS;
int send_to_station[CONVOYS][STATIONS] = {{0,0,0}};
int send_to_convoy[CONVOYS] = ZEROS;

clock TotalTime;
int schedule_length = 200;
int step = 0;
bool illegal_move = false;
bool execution_being_negative = false;

bool high_storage(ConvoyDescription&amp; convoy, int id){
	return convoy.storage * 75/100 &gt; storages[id];
}

bool medium_storage(ConvoyDescription&amp; convoy, int id){
	return convoy.storage * 50/100 &gt; storages[id];
}

bool low_storage(ConvoyDescription&amp; convoy, int id){
	return convoy.storage * 25/100 &gt; storages[id];
}

int accumulated_cost = 0;
int current_cost = 0;
int calculated_cost = 0;

void sort_lists(){
	int i,c,j;
	ExecutionDescription swap = {0,0,0};
	for (c = 0 ; c &lt; CONVOYS ; c++){
		for (i = 0 ; i &lt; convoys[c].processors - 1 ; i++){
			for (j = 0 ; j &lt; convoys[c].processors - i - 1 ; j++){
				if (convoy_tasks[c][j].execution_time &gt;= convoy_tasks[c][j+1].execution_time){
					swap = convoy_tasks[c][j];
					convoy_tasks[c][j] = convoy_tasks[c][j+1];
					convoy_tasks[c][j+1] = swap;
				}
			}	
		}
	}
}


</declaration><template><name>Scheduler</name><declaration>clock time;
int lowest;
void closest_task_to_finish(){	
	int i;
	lowest = 9999;	
	for (i = 0; i &lt; CONVOYS; i++){
		if (convoy_tasks[i][0].execution_time &lt; lowest){
			lowest = convoy_tasks[i][0].execution_time;
		}
	}
	if (lowest == 9999){
		lowest = 1;
	}
}

void update_processors(){
	int i, c;
	for (c = 0; c &lt; CONVOYS; c++){
		for (i = 0; i &lt; convoys[c].processors; i++){
			if (convoy_tasks[c][i].task_type != -1){
				convoy_tasks[c][i].execution_time -= lowest;
			}
			if (convoy_tasks[c][i].execution_time == 0){
				if (convoy_tasks[c][i].to_station != -1){
					send_to_station[c][convoy_tasks[c][i].to_station]--;
				}
				if (convoy_tasks[c][i].task_type == 0){
					gather_in_use[c]--;
				}
				proc_in_use[c]--;
				convoy_tasks[c][i].to_station = -1;
				convoy_tasks[c][i].task_type = -1;
				convoy_tasks[c][i].execution_time = 9999;
			}
			else if (convoy_tasks[c][i].execution_time-lowest &lt; 0){
				execution_being_negative = true;
			}
		}
	}
}



void update_storage(){
	int i, c;
	for (c = 0; c &lt; CONVOYS; c++){
		to_be_stored[c] = 0;
		for (i = 0; i &lt; MAX_PROCESSORS; i++){
			if (convoy_tasks[c][i].task_type != -1){ //if execution time is -1 indicate that the processor is not available for the convoy
				to_be_stored[c] += tasks[convoy_tasks[c][i].task_type].data_rate * lowest;
				storages[c] += tasks[convoy_tasks[c][i].task_type].data_rate * lowest;
			}
		}
	}
}
int ma;
int mb[STATIONS] = {0,0,0};

void calc_cost(){
	int i, c, s;
	calculated_cost = 0;
	for (c = 0; c &lt; CONVOYS; c++){
		//Cost goes up if we have low storage and no processes gathering data.
		if ((100-storages[c]*100/convoys[c].storage)*(100-gather_in_use[c]*100/convoys[c].processors)/1000 &gt;=
		    (storages[c]*100/convoys[c].storage)*(gather_in_use[c]*100/convoys[c].processors)/1000){
			ma = (100-storages[c]*100/convoys[c].storage)*(100-gather_in_use[c]*100/convoys[c].processors)/1000;
		}
		else {
			ma = (storages[c]*100/convoys[c].storage)*(gather_in_use[c]*100/convoys[c].processors)/1000;
		}
		//Cost goes up if we have high storage and no procceses sending to other convoys or stations on Earth
		//for (s = 0; s &lt; STATIONS; s++){
		//	if ((100-storages[c]*100/convoys[c].storage)*(100-send_to_station[c][s]*100/convoys[c].send_to_station[s])/1000 &gt;=
		//	    (storages[c]*100/convoys[c].storage)*(send_to_station[c][s]*100/convoys[c].send_to_station[s])/1000){
		//		mb[s] = (100-storages[c]*100/convoys[c].storage)*(100-send_to_station[c][s]*100/convoys[c].send_to_station[s])/1000;
		//	}
		//	else {
		//		mb[s] = (storages[c]*100/convoys[c].storage)*(send_to_station[c][s]*100/convoys[c].send_to_station[s])/1000;
		//	}
		//}
	}
}
</declaration><location id="id0" x="-64" y="80"><committed/></location><location id="id1" x="-256" y="184"><name x="-248" y="152">WaitingForTasks</name><label kind="invariant" x="-266" y="199">time &lt;= lowest &amp;&amp;
TotalTime &lt; schedule_length &amp;&amp;
!illegal_move &amp;&amp;
lowest != 0 &amp;&amp;
cost '== calculated_cost</label></location><location id="id2" x="-64" y="-16"><committed/></location><location id="id3" x="-256" y="-16"><name x="-352" y="-56">ScheduleTask</name><committed/></location><init ref="id3"/><transition><source ref="id0"/><target ref="id1"/><nail x="-64" y="184"/></transition><transition><source ref="id2"/><target ref="id3"/><label kind="guard" x="-240" y="-96">current_task &lt; TASKS-1</label><label kind="synchronisation" x="-240" y="-112">move!</label><label kind="assignment" x="-240" y="-72">current_task++</label><nail x="-64" y="-72"/><nail x="-256" y="-72"/></transition><transition><source ref="id1"/><target ref="id3"/><label kind="guard" x="-368" y="24">time == lowest</label><label kind="assignment" x="-368" y="40">current_task = 0,
accumulated_cost += current_cost,
update_storage(),
update_processors(),
sort_lists()</label></transition><transition><source ref="id2"/><target ref="id0"/><label kind="guard" x="-32" y="0">current_task == TASKS-1</label><label kind="synchronisation" x="-32" y="-16">move!</label><label kind="assignment" x="-32" y="24">time = 0,
sort_lists(),
closest_task_to_finish(),
calc_cost()</label></transition><transition><source ref="id3"/><target ref="id2"/><label kind="synchronisation" x="-240" y="-40">start_data_transfer!</label></transition></template><template><name>Convoy</name><parameter>const id_t id</parameter><declaration>int do_task[TASKS] = TASKS_ZERO;
int not_do_task[TASKS] = TASKS_ZERO;

int amount_of_tasks_to_execute(){
	if (low_storage(convoys[id], id)){
		return convoys[id].processors;
	}
	else if (medium_storage(convoys[id], id)){
		return convoys[id].processors/2;
	}
	else if (high_storage(convoys[id], id)){
		return convoys[id].processors/3;
	}
	else{
		return 1;
	}
}

int cheapest_available_station(){
	int i, j;
	int lowest = 9999;
	int position = 2;
	for (i = 0; i &lt; STATIONS; i++){
		if (convoys[id].send_to_station[i] &lt; send_to_station[id][i] &amp;&amp; lowest &gt; stations[i].cost){
			lowest = stations[i].cost;
			position = i;
		}
	}
	return position;	
}

void insert_task(TaskDescription item){
	int i;
	for(i = 0; i &lt; convoys[id].processors; i++){
		if (convoy_tasks[id][i].task_type == -1){
			proc_in_use[id]++;
			if (item.task_type == 0){// Gather data
				convoy_tasks[id][i].task_type = item.task_type;
				convoy_tasks[id][i].execution_time = item.execution_time;
				convoy_tasks[id][i].to_station = -1;
				gather_in_use[id]++;
				return;
			}
			else if (item.task_type == 1){//Send to station
				convoy_tasks[id][i].task_type = item.task_type;
				convoy_tasks[id][i].execution_time = item.execution_time;
				convoy_tasks[id][i].to_station = cheapest_available_station();
				send_to_station[id][convoy_tasks[id][i].to_station]++;
				return;
			}			
		}
	}
	illegal_move = true;
}

void add_tasks(TaskDescription task){
	int i = amount_of_tasks_to_execute();
	while(i){
		insert_task(task);
		i--;
	}	
}








</declaration><location id="id4" x="-160" y="0"><committed/></location><location id="id5" x="-160" y="-72"><committed/></location><location id="id6" x="-392" y="-40"></location><init ref="id6"/><transition><source ref="id5"/><target ref="id6"/><label kind="synchronisation" x="-360" y="-128">move?</label><nail x="-160" y="-104"/><nail x="-392" y="-104"/></transition><transition><source ref="id4"/><target ref="id6"/><label kind="synchronisation" x="-360" y="40">move?</label><nail x="-160" y="56"/><nail x="-392" y="56"/></transition><transition><source ref="id6"/><target ref="id4"/><label kind="synchronisation" x="-360" y="-24">start_data_transfer?</label><label kind="assignment" x="-360" y="0">do_task[current_task]++,
add_tasks(tasks[current_task])</label><nail x="-368" y="0"/></transition><transition><source ref="id6"/><target ref="id5"/><label kind="synchronisation" x="-360" y="-96">start_data_transfer?</label><label kind="assignment" x="-360" y="-72">not_do_task[current_task]++</label><nail x="-376" y="-72"/></transition></template><system>
system Convoy, Scheduler;</system></nta>